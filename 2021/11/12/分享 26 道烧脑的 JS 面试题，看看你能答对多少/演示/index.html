<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>分享 26 道烧脑的 JS 面试题，看看你能答对多少 | 你是个美好的人类</title><meta name="keywords" content="博客，兔子"><meta name="author" content="爱吃橙子的兔子"><meta name="copyright" content="爱吃橙子的兔子"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文精选了20多道具有一定迷惑性的js题，主要考察的是类型判断、作用域、this指向、原型、事件循环等知识点，每道题都配有笔者详细傻瓜式的解析，偏向于初学者，大佬请随意。">
<meta property="og:type" content="article">
<meta property="og:title" content="分享 26 道烧脑的 JS 面试题，看看你能答对多少">
<meta property="og:url" content="https://czlovee.github.io/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/index.html">
<meta property="og:site_name" content="你是个美好的人类">
<meta property="og:description" content="本文精选了20多道具有一定迷惑性的js题，主要考察的是类型判断、作用域、this指向、原型、事件循环等知识点，每道题都配有笔者详细傻瓜式的解析，偏向于初学者，大佬请随意。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-19fd33c5a591cc2eedfaa089075e73c8_r.jpg&refer=http%3A%2F%2Fpic3.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641517392&t=bdd99a8c0a6416b45ba2c61eb000bbc3">
<meta property="article:published_time" content="2021-11-12T10:00:00.000Z">
<meta property="article:modified_time" content="2021-12-08T01:03:16.543Z">
<meta property="article:author" content="爱吃橙子的兔子">
<meta property="article:tag" content="博客，兔子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-19fd33c5a591cc2eedfaa089075e73c8_r.jpg&refer=http%3A%2F%2Fpic3.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641517392&t=bdd99a8c0a6416b45ba2c61eb000bbc3"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://czlovee.github.io/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分享 26 道烧脑的 JS 面试题，看看你能答对多少',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2021-12-08 09:03:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp6.itc.cn%2Fimages01%2F20200712%2F56bcc0529aa5479283c52aaaab46439d.jpeg&amp;refer=http%3A%2F%2Fp6.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1636338783&amp;t=f6be0715c354b4c41d727056bd44a57c" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-19fd33c5a591cc2eedfaa089075e73c8_r.jpg&amp;refer=http%3A%2F%2Fpic3.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641517392&amp;t=bdd99a8c0a6416b45ba2c61eb000bbc3')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">你是个美好的人类</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 找文章</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">分享 26 道烧脑的 JS 面试题，看看你能答对多少</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-12T10:00:00.000Z" title="发表于 2021-11-12 18:00:00">2021-11-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-08T01:03:16.543Z" title="更新于 2021-12-08 09:03:16">2021-12-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="分享 26 道烧脑的 JS 面试题，看看你能答对多少"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="分享-26-道烧脑的-JS-面试题，看看你能答对多少"><a href="#分享-26-道烧脑的-JS-面试题，看看你能答对多少" class="headerlink" title="分享 26 道烧脑的 JS 面试题，看看你能答对多少"></a>分享 26 道烧脑的 JS 面试题，看看你能答对多少</h1><hr>
<p>本文精选了20多道具有一定迷惑性的js题，主要考察的是类型判断、作用域、this指向、原型、事件循环等知识点，每道题都配有笔者详细傻瓜式的解析，偏向于初学者，大佬请随意。</p>
<h4 id="第-1题"><a href="#第-1题" class="headerlink" title="第 1题"></a><em>第 1题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">b(a)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>

<p><em><strong>答案</strong></em></p>
<p>2、1</p>
<p><em><strong>解析</strong></em></p>
<p>首先基本类型数据是按值传递的，所以执行b函数时，b的参数a接收的值为1，参数a相当于函数内部的变量，当本作用域有和上层作用域同名的变量时，无法访问到上层变量，所以函数内无论怎么修改a，都不影响上层，所以函数内部打印的a是2，外面打印的仍是1。</p>
<h4 id="第-2题"><a href="#第-2题" class="headerlink" title="第 2题"></a><em>第 2题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params">b = c, c = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b, c)</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>报错</p>
<p><em><strong>解析</strong></em></p>
<p>给函数多个参数设置默认值实际上跟按顺序定义变量一样，所以会存在暂时性死区的问题，即前面定义的变量不能引用后面还未定义的变量，而后面的可以访问前面的。</p>
<h4 id="第-3题"><a href="#第-3题" class="headerlink" title="第 3题"></a><em>第 3题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = b = <span class="number">10</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">let</span> a = b = <span class="number">20</span> </span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>10、20</p>
<p><em><strong>解析</strong></em></p>
<p>连等操作是从右向左执行的，相当于b = 10、let a = b，很明显b没有声明就直接赋值了，所以会隐式创建为一个全局变量，函数内的也是一样，并没有声明b，直接就对b赋值了，因为作用域链，会一层一层向上查找，找了到全局的b，所以全局的b就被修改为20了，而函数内的a因为重新声明了，所以只是局部变量，不影响全局的a，所以a还是10。</p>
<h4 id="第-4题"><a href="#第-4题" class="headerlink" title="第 4题"></a><em>第 4题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.x)</span><br><span class="line"><span class="built_in">console</span>.log(b.x)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>undefined、{n: 2}</p>
<p><em><strong>解析</strong></em></p>
<p>反正按照网上大部分的解释是因为.运算符优先级最高，所以会先执行a.x，此时a、b共同指向的{n: 1}变成了{n: 1, x: undefined}，然后按照连等操作从右到左执行代码，a = {n: 2}，显然，a现在指向了一个新对象，然后a.x = a，因为a.x最开始就执行过了，所以这里其实等价于：({n: 1, x: undefined}).x = b.x = a = {n: 2}。</p>
<h4 id="第-5题"><a href="#第-5题" class="headerlink" title="第 5题"></a><em>第 5题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr[<span class="number">10</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x === <span class="literal">undefined</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>[]</p>
<p><em><strong>解析</strong></em></p>
<p>这题比较简单，arr[10]=10，那么索引3到9位置上都是undefined，arr[3]等打印出来也确实是undefined，但是，这里其实涉及到ECMAScript版本不同对应方法行为不同的问题，ES6之前的遍历方法都会跳过数组未赋值过的位置，也就是空位，但是ES6新增的for of方法就不会跳过。</p>
<h4 id="第-6题"><a href="#第-6题" class="headerlink" title="第 6题"></a><em>第 6题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">&#x27;Goodbye &#x27;</span> + name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.info(<span class="string">&#x27;Hello &#x27;</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>Goodbye Jack</p>
<p><em><strong>解析</strong></em></p>
<p>这道题考察的是变量提升的问题，var声明变量时会把变量自动提升到当前作用域顶部，所以函数内的name虽然是在if分支里声明的，但是也会提升到外层，因为和全局的变量name重名，所以访问不到外层的name，最后因为已声明未赋值的变量的值都为undefined，导致if的第一个分支满足条件。</p>
<h4 id="第-7题"><a href="#第-7题" class="headerlink" title="第 7题"></a><em>第 7题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">NaN</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;1&quot;</span> + <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">undefined</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + <span class="literal">null</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + &#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + [])</span><br><span class="line"><span class="built_in">console</span>.log([] + &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>NaN、13、NaN、1、1[object Object]、1、[object Object]</p>
<p><em><strong>解析</strong></em></p>
<p>这道题考察的显然是+号的行为：</p>
<p>1.如果有一个操作数是字符串，那么把另一个操作数转成字符串执行连接</p>
<p>2.如果有一个操作数是对象，那么调用对象的valueOf方法转成原始值，如果没有该方法或调用后仍是非原始值，则调用toString方法</p>
<p>3.其他情况下，两个操作数都会被转成数字执行加法操作</p>
<h4 id="第-8题"><a href="#第-8题" class="headerlink" title="第 8题"></a><em>第 8题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;&#125;,</span><br><span class="line">    b=&#123;<span class="attr">key</span>:<span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">    c=&#123;<span class="attr">key</span>:<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">a[b]=<span class="number">123</span></span><br><span class="line">a[c]=<span class="number">456</span></span><br><span class="line"><span class="built_in">console</span>.log(a[b])</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>456</p>
<p><em><strong>解析</strong></em></p>
<p>对象有两种方法设置和引用属性，obj.name和obj[‘name’]，方括号里可以字符串、数字和变量设置是表达式等，但是最终计算出来得是一个字符串，对于上面的b和c，它们两个都是对象，所以会调用toString()方法转成字符串，对象转成字符串和数组不一样，和内容无关，结果都是[object Obejct]，所以a[b]=a[c]=a[‘[object Object]’]。</p>
<h4 id="第-9题"><a href="#第-9题" class="headerlink" title="第 9题"></a><em>第 9题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> out = <span class="number">25</span></span><br><span class="line"><span class="keyword">var</span> inner = &#123;</span><br><span class="line">  <span class="attr">out</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">func</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> out = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.out</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log((inner.func, inner.func)())</span><br><span class="line"><span class="built_in">console</span>.log(inner.func())</span><br><span class="line"><span class="built_in">console</span>.log((inner.func)())</span><br><span class="line"><span class="built_in">console</span>.log((inner.func = inner.func)())</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>25、20、20、25</p>
<p><em><strong>解析</strong></em></p>
<p>这道题考察的是this指向问题：</p>
<p>1.逗号操作符会返回表达式中的最后一个值，这里为inner.func对应的函数，注意是函数本身，然后执行该函数，该函数并不是通过对象的方法调用，而是在全局环境下调用，所以this指向window，打印出来的当然是window下的out</p>
<p>2.这个显然是以对象的方法调用，那么this指向该对象</p>
<p>3.加了个括号，看起来有点迷惑人，但实际上(inner.func)和inner.func是完全相等的，所以还是作为对象的方法调用</p>
<p>4.赋值表达式和逗号表达式相似，都是返回的值本身，所以也相对于在全局环境下调用函数</p>
<h4 id="第-10题"><a href="#第-10题" class="headerlink" title="第 10题"></a><em>第 10题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;a,b,c&#125; = &#123; <span class="attr">c</span>:<span class="number">3</span>, <span class="attr">b</span>:<span class="number">2</span>, <span class="attr">a</span>:<span class="number">1</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>1、2、3</p>
<p><em><strong>解析</strong></em></p>
<p>这题考察的是变量解构赋值的问题，数组解构赋值是按位置对应的，而对象只要变量与属性同名，顺序随意。</p>
<h4 id="第-11题"><a href="#第-11题" class="headerlink" title="第 11题"></a><em>第 11题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]))</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>[4, 5, 3]</p>
<p><em><strong>解析</strong></em></p>
<p>是不是从来没有用assign方法合并过数组？assign方法可以用于处理数组，不过会把数组视为对象，比如这里会把目标数组视为是属性为0、1、2的对象，所以源数组的0、1属性的值覆盖了目标对象的值。</p>
<h4 id="第-12题"><a href="#第-12题" class="headerlink" title="第 12题"></a><em>第 12题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">1</span></span><br><span class="line"><span class="keyword">switch</span>(x++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: ++x</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: ++x</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>4</p>
<p><em><strong>解析</strong></em></p>
<p>这题考查的是自增运算符的前缀版和后缀版，以及switch的语法，后缀版的自增运算符会在语句被求值后才发生，所以x会仍以1的值去匹配case分支，那么显然匹配到为1的分支，此时，x++生效，x变成2，再执行++x，变成3，因为没有break语句，所以会进入当前case后面的分支，所以再次++x，最终变成4。</p>
<h4 id="第-13题"><a href="#第-13题" class="headerlink" title="第 13题"></a><em>第 13题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span> == <span class="keyword">typeof</span> NULL)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; == <span class="keyword">typeof</span> <span class="class"><span class="keyword">class</span> </span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>true、true</p>
<p><em><strong>解析</strong></em></p>
<p>1.首先不要把NULL看成是null，js的关键字是区分大小写的，所以这就是一个普通的变量，而且没有声明，typeof对没有声明的变量使用是不会报错的，返回’undefined’，typeof对undefined使用也是’undefined’，所以两者相等</p>
<p>2.typeof对函数使用返回’function’，class只是es6新增的语法糖，本质上还是函数，所以两者相等</p>
<h4 id="第-14题"><a href="#第-14题" class="headerlink" title="第 14题"></a><em>第 14题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(!!<span class="keyword">typeof</span> count === <span class="string">&quot;number&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>true、false</p>
<p><em><strong>解析</strong></em></p>
<p>1.没啥好说的，typeof对数字类型返回’number’。</p>
<p>2.这题考查的是运算符优先级的问题，逻辑非!的优先级比全等===高，所以先执行!!typeof count，结果为true，然后执行true === ‘number’，结果当然为false。</p>
<h4 id="第-15题"><a href="#第-15题" class="headerlink" title="第 15题"></a><em>第 15题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a)</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>2、2</p>
<p><em><strong>解析</strong></em></p>
<p>var声明会把变量提升到当前作用域顶部，所以a=1并不会报错，另外在全局作用域下使用var声明变量，该变量会变成window的一个属性，以上两点都和是否在严格模式下无关。</p>
<h4 id="第-16题"><a href="#第-16题" class="headerlink" title="第 16题"></a><em>第 16题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">  b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>1</p>
<p><em><strong>解析</strong></em></p>
<p>这道题考察的是作用域的问题，作用域其实就是一套变量的查找规则，每个函数在执行时都会创建一个执行上下文，其中会关联一个变量对象，也就是它的作用域，上面保存着该函数能访问的所有变量，另外上下文中的代码在执行时还会创建一个作用域链，如果某个标识符在当前作用域中没有找到，会沿着外层作用域继续查找，直到最顶端的全局作用域，因为js是词法作用域，在写代码阶段就作用域就已经确定了，换句话说，是在函数定义的时候确定的，而不是执行的时候，所以a函数是在全局作用域中定义的，虽然在b函数内调用，但是它只能访问到全局的作用域而不能访问到b函数的作用域。</p>
<h4 id="第-17题"><a href="#第-17题" class="headerlink" title="第 17题"></a><em>第 17题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;abc&#x27;</span>,</span><br><span class="line">  <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.name = <span class="string">&#x27;bcd&#x27;</span></span><br><span class="line">obj.fn()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>undefined</p>
<p><em><strong>解析</strong></em></p>
<p>这道题考察的是this的指向问题，箭头函数执行的时候上下文是不会绑定this的，所以它里面的this取决于外层的this，这里函数执行的时候外层是全局作用域，所以this指向window，window对象下没有name属性，所以是undefined。</p>
<h4 id="第-18题"><a href="#第-18题" class="headerlink" title="第 18题"></a><em>第 18题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">a</span>: &#123;</span><br><span class="line">    <span class="attr">b</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(obj, obj1))</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>{a: {b: 1}}</p>
<p><em><strong>解析</strong></em></p>
<p>这道题很简单，因为assign方法执行的是浅拷贝，所以源对象的a属性会直接覆盖目标对象的a属性。</p>
<h4 id="第-19题"><a href="#第-19题" class="headerlink" title="第 19题"></a><em>第 19题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> getNum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">getNum()</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>undefined、1、2</p>
<p><em><strong>解析</strong></em></p>
<p>首先因为var声明的变量提升作用，所以a变量被提升到顶部，未赋值，所以第一个打印出来的是undefined。</p>
<p>接下来是函数声明和函数表达式的区别，函数声明会有提升作用，在代码执行前就把函数提升到顶部，在执行上下文上中生成函数定义，所以第二个getNum会被最先提升到顶部，然后是var声明getNum的提升，但是因为getNum函数已经被声明了，所以就不需要再声明一个同名变量，接下来开始执行代码，执行到var getNum = fun…时，虽然声明被提前了，但是赋值操作还是留在这里，所以getNum被赋值为了一个函数，下面的函数声明直接跳过，最后，getNum函数执行前a打印出来还是1，执行后，a被修改成了2，所以最后打印出来的2。</p>
<h4 id="第-20题"><a href="#第-20题" class="headerlink" title="第 20题"></a><em>第 20题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(scope)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">a()()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>undefined</p>
<p><em><strong>解析</strong></em></p>
<p>这题考查的还是变量提升和作用域的问题，虽然var声明是在return语句后面，但还是会提升到a函数作用域的顶部，然后又因为作用域是在函数定义的时候确定的，与调用位置无关，所以b的上层作用域是a函数，scope在b自身的作用域里没有找到，向上查找找到了自动提升的并且未赋值的scope变量，所以打印出undefined。</p>
<h4 id="第-21题"><a href="#第-21题" class="headerlink" title="第 21题"></a><em>第 21题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [fn]</span><br><span class="line">arr[<span class="number">0</span>]()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>打印出arr数组本身</p>
<p><em><strong>解析</strong></em></p>
<p>函数作为某个对象的方法调用，this指向该对象，数组显然也是对象，只不过我们都习惯了对象引用属性的方法：obj.fn，但是实际上obj[‘fn’]引用也是可以的。</p>
<h4 id="第-22题"><a href="#第-22题" class="headerlink" title="第 22题"></a><em>第 22题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>1、b函数本身、b函数本身</p>
<p><em><strong>解析</strong></em></p>
<p>这三小题都涉及到函数声明和var声明，这两者都会发生提升，但是函数会优先提升，所以如果变量和函数同名的话，变量的提升就忽略了。</p>
<p>1.提升完后，执行到赋值代码，a被赋值成了1，函数因为已经声明提升了，所以跳过，最后打印a就是1。</p>
<p>2.和第一题类似，只是b没有赋值操作，那么执行到这两行相当于都没有操作，b当然是函数。</p>
<p>3.和第二题类似，只是先后顺序换了一下，但是并不影响两者的提升顺序，仍是函数优先，同名的var声明提升忽略，所以打印出b还是函数。</p>
<h4 id="第-23题"><a href="#第-23题" class="headerlink" title="第 23题"></a><em>第 23题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">3</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">4</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">5</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName()</span><br><span class="line">getName()</span><br><span class="line">Foo().getName()</span><br><span class="line">getName()</span><br><span class="line"><span class="keyword">new</span> Foo.getName()</span><br><span class="line"><span class="keyword">new</span> Foo().getName()</span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>2、4、1、1、2、3、3</p>
<p><em><strong>解析</strong></em></p>
<p>这是一道综合性题目，首先getName函数声明会先提升，然后getName函数表达式提升，但是因为函数声明提升在线，所以忽略函数表达式的提升，然后开始执行代码，执行到var getName= …时，修改了getName的值，赋值成了打印4的新函数。</p>
<p>1.执行Foo函数的静态方法，打印出2。</p>
<p>2.执行getName，当前getName是打印出4的那个函数。</p>
<p>3.执行Foo函数，修改了全局变量getName，赋值成了打印1的函数，然后返回this，因为是在全局环境下执行，所以this指向window，因为getName已经被修改了，所以打印出1。</p>
<p>4.因为getName没有被重新赋值，所以再执行仍然打印出1。</p>
<p>5.new操作符是用来调用函数的，所以new Foo.getName()相当于new (Foo.getName)()，所以new的是Foo的静态方法getName，打印出2。</p>
<p>6.因为点运算符（.）的优先级和new是一样高的，所以从左往右执行，相当于(new Foo()).getName()，对Foo使用new调用会返回一个新创建的对象，然后执行该对象的getName方法，该对象本身并没有该方法，所以会从Foo的原型对象上查找，找到了，所以打印出3。</p>
<p>7.和上题一样，点运算符（.）的优先级和new一样高，另外new是用来调用函数的，所以new new Foo().getName()相当于new ((new Foo()).getName)()，括号里面的就是上一题，所以最后找到的是Foo原型上的方法，无论是直接调用，还是通过new调用，都会执行该方法，所以打印出3。</p>
<h4 id="第-24题"><a href="#第-24题" class="headerlink" title="第 24题"></a><em>第 24题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line"> <span class="attr">address</span>: &#123;</span><br><span class="line">  <span class="attr">country</span>:<span class="string">&quot;china&quot;</span>,</span><br><span class="line">  <span class="attr">city</span>:<span class="string">&quot;hangzhou&quot;</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">say</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`it&#x27;s <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>, from <span class="subst">$&#123;<span class="built_in">this</span>.address.country&#125;</span>`</span>)</span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="attr">setCountry</span>:<span class="function"><span class="keyword">function</span> (<span class="params">country</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.address.country=country</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Object</span>.create(person)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="built_in">Object</span>.create(person)</span><br><span class="line"></span><br><span class="line">p1.name = <span class="string">&quot;Matthew&quot;</span></span><br><span class="line">p1.setCountry(<span class="string">&quot;American&quot;</span>)</span><br><span class="line"></span><br><span class="line">p2.name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">p2.setCountry(<span class="string">&quot;England&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1.say()</span><br><span class="line">p2.say()</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>it’s Matthew, from England</p>
<p>it’s Bob, from England</p>
<p><em><strong>解析</strong></em></p>
<p>Object.create方法会创建一个对象，并且将该对象的__proto__属性指向传入的对象，所以p1和p2两个对象的原型对象指向了同一个对象，接着给p1添加了一个name属性，然后调用了p1的setCountry方法，p1本身是没有这个方法的，所以会沿着原型链进行查找，在它的原型上，也就是person对象上找到了这个方法，执行这个方法会给address对象的country属性设置传入的值，p1本身也是没有address属性的，但是和name属性不一样，address属性在原型对象上找到了，并且因为是个引用值，所以会成功修改它的country属性，接着对p2的操作也是一样，然后因为原型中存在引用值会在所有实例中共享，所以p1和p2它们引用的address也是同一个对象，一个实例修改了，会反映到所有实例上，所以p2的修改会覆盖p1的修改，最终country的值为England。</p>
<h4 id="第-25题"><a href="#第-25题" class="headerlink" title="第 25题"></a><em>第 25题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;<span class="number">10000</span> ; i++ ) &#123;</span><br><span class="line">    i == <span class="number">9999</span> &amp;&amp; resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>2、3、5、4、1</p>
<p><em><strong>解析</strong></em></p>
<p>这道题显然考察的是事件循环的知识点。</p>
<p>js是一门单线程的语言，但是为了执行一些异步任务时不阻塞代码，以及避免等待期间的资源浪费，js存在事件循环的机制，单线程指的是执行js的线程，称作主线程，其他还有一些比如网络请求的线程、定时器的线程，主线程在运行时会产生执行栈，栈中的代码如果调用了异步api的话则会把事件添加到事件队列里，只要该异步任务有了结果便会把对应的回调放到【任务队列】里，当执行栈中的代码执行完毕后会去读取任务队列里的任务，放到主线程执行，当执行栈空了又会去检查，如此往复，也就是所谓的事件循环。</p>
<p>异步任务又分为【宏任务】（比如setTimeout、setInterval）和【微任务】（比如promise），它们分别会进入不同的队列，执行栈为空完后会优先检查微任务队列，如果有微任务的话会一次性执行完所有的微任务，然后去宏任务队列里检查，如果有则取出一个任务到主线程执行，执行完后又会去检查微任务队列，如此循环。</p>
<p>回到这题，首先整体代码作为一个宏任务开始执行，遇到setTimeout，相应回调会进入宏任务队列，然后是promise，promise的回调是同步代码，所以会打印出2，for循环结束后调用了resolve，所以then的回调会被放入微任务队列，然后打印出3，最后打印出5，到这里当前的执行栈就空了，那么先检查微任务队列，发现有一个任务，那么取出来放到主线程执行，打印出4，最后检查宏任务队列，把定时器的回调放入主线程执行，打印出1。</p>
<h4 id="第-26题"><a href="#第-26题" class="headerlink" title="第 26题"></a><em>第 26题</em></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;10&#x27;</span>);</span><br><span class="line">  &#125;) </span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;11&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;12&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><em><strong>答案</strong></em></p>
<p>1、7、6、8、2、4、9、11、3、10、5、12</p>
<p><em><strong>解析</strong></em></p>
<p>这道题和上一题差不多，但是出现了process.nextTick，所以显然是在node环境下，node也存在事件循环的概念，但是和浏览器的有点不一样，nodejs中的宏任务被分成了几种不同的阶段，两个定时器属于timers阶段，setImmediate属于check阶段，socket的关闭事件属于close callbacks阶段，其他所有的宏任务都属于poll阶段，除此之外，只要执行到前面说的某个阶段，那么会执行完该阶段所有的任务，这一点和浏览器不一样，浏览器是每次取一个宏任务出来执行，执行完后就跑去检查微任务队列了，但是nodejs是来都来了，一次全部执行完该阶段的任务好了，那么process.nextTick和微任务在什么阶段执行呢，在前面说的每个阶段的后面都会执行，但是process.nextTick会优先于微任务，一图胜千言：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHpicYrciafd3U8o83thyl6lpgBSlmhTCIO0wVmrK8zBUEZgbYMaCErpOhfFPRlxuJ8MGGMf7gNU1zaA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>理解了以后再来分析这道题就很简单了，首先执行整体代码，先打印出1，setTimeout回调扔进timers队列，nextTick的扔进nextTick的队列，promise的回调是同步代码，执行后打印出7，then回调扔进微任务队列，然后又是一个setTimeout回调扔进timers队列，到这里当前节点就结束了，检查nextTick和微任务队列，nextTick队列有任务，执行后打印出6，微任务队列也有，打印出8，接下来按顺序检查各个阶段，check队列、close callbacks队列都没有任务，到了timers阶段，发现有两个任务，先执行第一个，打印出2，然后nextTick的扔进nextTick的队列，执行promise打印出4，then回调扔进微任务队列，再执行第二个setTimeout的回调，打印出9，然后和刚才一样，nextTick的扔进nextTick的队列，执行promise打印出11，then回调扔进微任务队列，到这里timers阶段也结束了，执行nextTick队列的任务，发现又两个任务，依次执行，打印出3和10，然后检查微任务队列，也是两个任务，依次执行，打印出5和12，到这里是有队列都清空了。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">爱吃橙子的兔子</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://czlovee.github.io/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/">https://czlovee.github.io/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://czlovee.github.io" target="_blank">你是个美好的人类</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-19fd33c5a591cc2eedfaa089075e73c8_r.jpg&amp;refer=http%3A%2F%2Fpic3.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641517392&amp;t=bdd99a8c0a6416b45ba2c61eb000bbc3" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/11/10/FormData.get%E5%92%8Cset%E5%AF%B9%E4%BA%8EIE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/%E6%BC%94%E7%A4%BA/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F93042c0460de0f1daf230e567f31e414.png&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641376298&amp;t=21c6e68fecb756cbcefcbd2ebe0c8de0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">FormData.get和set在IE浏览器和IE浏览器中均不起作用</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NDQwMS8zMDg3Mg=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fp6.itc.cn%2Fimages01%2F20200712%2F56bcc0529aa5479283c52aaaab46439d.jpeg&amp;refer=http%3A%2F%2Fp6.itc.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1636338783&amp;t=f6be0715c354b4c41d727056bd44a57c" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">爱吃橙子的兔子</div><div class="author-info__description">兔子博客，欢迎访问</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CZLOVEE"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/CZLOVEE" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sc_7895123@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到兔子博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E4%BA%AB-26-%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84-JS-%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91"><span class="toc-number">1.</span> <span class="toc-text">分享 26 道烧脑的 JS 面试题，看看你能答对多少</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-1%E9%A2%98"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">第 1题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-2%E9%A2%98"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">第 2题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-3%E9%A2%98"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">第 3题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-4%E9%A2%98"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">第 4题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-5%E9%A2%98"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">第 5题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-6%E9%A2%98"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">第 6题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-7%E9%A2%98"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">第 7题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-8%E9%A2%98"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">第 8题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-9%E9%A2%98"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">第 9题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-10%E9%A2%98"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">第 10题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-11%E9%A2%98"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">第 11题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-12%E9%A2%98"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">第 12题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-13%E9%A2%98"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">第 13题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-14%E9%A2%98"><span class="toc-number">1.0.0.14.</span> <span class="toc-text">第 14题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-15%E9%A2%98"><span class="toc-number">1.0.0.15.</span> <span class="toc-text">第 15题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-16%E9%A2%98"><span class="toc-number">1.0.0.16.</span> <span class="toc-text">第 16题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-17%E9%A2%98"><span class="toc-number">1.0.0.17.</span> <span class="toc-text">第 17题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-18%E9%A2%98"><span class="toc-number">1.0.0.18.</span> <span class="toc-text">第 18题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-19%E9%A2%98"><span class="toc-number">1.0.0.19.</span> <span class="toc-text">第 19题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-20%E9%A2%98"><span class="toc-number">1.0.0.20.</span> <span class="toc-text">第 20题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-21%E9%A2%98"><span class="toc-number">1.0.0.21.</span> <span class="toc-text">第 21题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-22%E9%A2%98"><span class="toc-number">1.0.0.22.</span> <span class="toc-text">第 22题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-23%E9%A2%98"><span class="toc-number">1.0.0.23.</span> <span class="toc-text">第 23题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-24%E9%A2%98"><span class="toc-number">1.0.0.24.</span> <span class="toc-text">第 24题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-25%E9%A2%98"><span class="toc-number">1.0.0.25.</span> <span class="toc-text">第 25题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC-26%E9%A2%98"><span class="toc-number">1.0.0.26.</span> <span class="toc-text">第 26题</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/" title="分享 26 道烧脑的 JS 面试题，看看你能答对多少"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic3.zhimg.com%2Fv2-19fd33c5a591cc2eedfaa089075e73c8_r.jpg&amp;refer=http%3A%2F%2Fpic3.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641517392&amp;t=bdd99a8c0a6416b45ba2c61eb000bbc3" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分享 26 道烧脑的 JS 面试题，看看你能答对多少"/></a><div class="content"><a class="title" href="/2021/11/12/%E5%88%86%E4%BA%AB%2026%20%E9%81%93%E7%83%A7%E8%84%91%E7%9A%84%20JS%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%BD%A0%E8%83%BD%E7%AD%94%E5%AF%B9%E5%A4%9A%E5%B0%91/%E6%BC%94%E7%A4%BA/" title="分享 26 道烧脑的 JS 面试题，看看你能答对多少">分享 26 道烧脑的 JS 面试题，看看你能答对多少</a><time datetime="2021-11-12T10:00:00.000Z" title="发表于 2021-11-12 18:00:00">2021-11-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/10/FormData.get%E5%92%8Cset%E5%AF%B9%E4%BA%8EIE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/%E6%BC%94%E7%A4%BA/" title="FormData.get和set在IE浏览器和IE浏览器中均不起作用"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2Fimg_convert%2F93042c0460de0f1daf230e567f31e414.png&amp;refer=http%3A%2F%2Fimg-blog.csdnimg.cn&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641376298&amp;t=21c6e68fecb756cbcefcbd2ebe0c8de0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FormData.get和set在IE浏览器和IE浏览器中均不起作用"/></a><div class="content"><a class="title" href="/2021/11/10/FormData.get%E5%92%8Cset%E5%AF%B9%E4%BA%8EIE%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/%E6%BC%94%E7%A4%BA/" title="FormData.get和set在IE浏览器和IE浏览器中均不起作用">FormData.get和set在IE浏览器和IE浏览器中均不起作用</a><time datetime="2021-11-10T14:00:00.000Z" title="发表于 2021-11-10 22:00:00">2021-11-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/03/Vue%E9%A1%B9%E7%9B%AEIE%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E4%B8%8D%E8%B7%B3%E8%BD%ACbug/%E6%BC%94%E7%A4%BA/" title="Vue项目:IE中地址栏直接改变路由页面不跳转bug"><img src="https://img0.baidu.com/it/u=165862810,1746596395&amp;fm=26&amp;fmt=auto" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Vue项目:IE中地址栏直接改变路由页面不跳转bug"/></a><div class="content"><a class="title" href="/2021/11/03/Vue%E9%A1%B9%E7%9B%AEIE%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E7%9B%B4%E6%8E%A5%E6%94%B9%E5%8F%98%E8%B7%AF%E7%94%B1%E9%A1%B5%E9%9D%A2%E4%B8%8D%E8%B7%B3%E8%BD%ACbug/%E6%BC%94%E7%A4%BA/" title="Vue项目:IE中地址栏直接改变路由页面不跳转bug">Vue项目:IE中地址栏直接改变路由页面不跳转bug</a><time datetime="2021-11-03T13:05:00.000Z" title="发表于 2021-11-03 21:05:00">2021-11-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/02/IE8%E5%8F%8A%E5%85%B6%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E4%B9%8Binput%20file/%E6%BC%94%E7%A4%BA/" title="IE8及其以下版本兼容性问题之input file 隐藏上传文件"><img src="https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/baike/s%3D220/sign=3f22728377c6a7efbd26af24cdfbafe9/94cad1c8a786c917a70d8565c83d70cf3bc75764.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IE8及其以下版本兼容性问题之input file 隐藏上传文件"/></a><div class="content"><a class="title" href="/2021/11/02/IE8%E5%8F%8A%E5%85%B6%E4%BB%A5%E4%B8%8B%E7%89%88%E6%9C%AC%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E4%B9%8Binput%20file/%E6%BC%94%E7%A4%BA/" title="IE8及其以下版本兼容性问题之input file 隐藏上传文件">IE8及其以下版本兼容性问题之input file 隐藏上传文件</a><time datetime="2021-11-02T12:30:20.000Z" title="发表于 2021-11-02 20:30:20">2021-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/01/URL%E4%BC%A0%E5%8F%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/%E6%BC%94%E7%A4%BA/" title="IE、FireFox、Chrome浏览器中关于URL传参中文乱码，解决兼容性问题！"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fim5.tongbu.com%2Ftbnews%2F202001%2F2a906b36-b.jpg%3Fw%3D700%2C500%26b%3D47&amp;refer=http%3A%2F%2Fim5.tongbu.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1641372202&amp;t=674fc177873199c48fafc9ede338d36e" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IE、FireFox、Chrome浏览器中关于URL传参中文乱码，解决兼容性问题！"/></a><div class="content"><a class="title" href="/2021/11/01/URL%E4%BC%A0%E5%8F%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/%E6%BC%94%E7%A4%BA/" title="IE、FireFox、Chrome浏览器中关于URL传参中文乱码，解决兼容性问题！">IE、FireFox、Chrome浏览器中关于URL传参中文乱码，解决兼容性问题！</a><time datetime="2021-11-01T12:00:00.000Z" title="发表于 2021-11-01 20:00:00">2021-11-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 爱吃橙子的兔子</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>